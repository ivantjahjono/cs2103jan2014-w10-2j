//@author: a0099175n



	/**
	 * origin: src\kaboom\logic\FormatIdentify.java
	 */


package kaboom.logic;

public class FormatIdentify {
	KEYWORD_TYPE type;
	String stringText;
	
	public FormatIdentify () {
		type = KEYWORD_TYPE.INVALID;
		stringText = "";
	}
	
	public void setCommandStringFormat (String text) {
		stringText = text;
	}
	
	public String getCommandStringFormat () {
		return stringText;
	}
	
	public void setType (KEYWORD_TYPE newType) {
		type = newType;
	}
	
	public KEYWORD_TYPE getType () {
		return type;
	}
}

	// End of segment: src\kaboom\logic\FormatIdentify.java





	/**
	 * origin: src\kaboom\logic\FormatIdentifyComparator.java
	 */

package kaboom.logic;

import java.util.Comparator;

public class FormatIdentifyComparator implements Comparator<FormatIdentify> {

	@Override
	public int compare(FormatIdentify firstIdentify, FormatIdentify secondIdentify) {

		int firstValue = firstIdentify.getType().getValue();
		int secondValue = secondIdentify.getType().getValue();
		if (firstValue > secondValue) {
			return 1;
		} else if (secondValue > firstValue) {
			return -1;
		}
		return 0;
	}
}

	// End of segment: src\kaboom\logic\FormatIdentifyComparator.java





	/**
	 * origin: src\kaboom\logic\KeytypeIndexPair.java
	 */

package kaboom.logic;

class KeytypeIndexPair {
	KEYWORD_TYPE type;
	int indexPosition;
	
	public KeytypeIndexPair () {
		type = KEYWORD_TYPE.INVALID;
		indexPosition = -1;
	}
	
	public KeytypeIndexPair (KEYWORD_TYPE newType, int position) {
		setType(newType);
		setIndexPosition(position);
	}
	
	public void setType (KEYWORD_TYPE newType) {
		type = newType;
	}
	
	public void setIndexPosition (int position) {
		indexPosition = position;
	}
	
	public KEYWORD_TYPE getType () {
		return type;
	}
	
	public int getIndexPosition () {
		return  indexPosition;
	}
	
	public String toString () {
		return "[" + type + ", " + indexPosition + "]";
	}
}
	// End of segment: src\kaboom\logic\KeytypeIndexPair.java





	/**
	 * origin: src\kaboom\ui\DisplayData.java
	 */


package kaboom.ui;

import java.util.Observable;
import java.util.Vector;

import kaboom.logic.DateAndTimeFormat;
import kaboom.logic.FormatIdentify;
import kaboom.logic.Result;
import kaboom.logic.TaskInfo;
import kaboom.storage.TaskListShop;
import kaboom.storage.TaskView;

/**
 * Returns a vector of TaskInfoDisplay which contains all the 
 * tasks that is displayed.
 * <p>
 * This Singleton class contains all the information that User Interface
 * needs to display. It holds all the tasks, command feedback,
 * current page the UI is on.
 */
public class DisplayData extends Observable {
	// TODO clean up methods

	final int NUM_OF_TASK_PER_PAGE = 10;

	static DisplayData instance;

	TaskListShop 	taskListShop;

	Vector<TaskInfoDisplay> tasksDataToDisplay;
	Vector<FormatIdentify> 	formattingCommand;
	Vector<Integer> 		taskCountList;

	String 	userFeedbackMessage;
	int 	currentPage;
	
	String currentWeekDay;
	String currentDate;
	String currentTime;

	DISPLAY_STATE currentDisplayState;

	/**
	 * Returns a DisplayData instance of the class.
	 * <p>
	 * This method always return DisplayData. The instance will be
	 * created when it is first called. Subsequent calls will return
	 * the first created instance.
	 *
	 */
	public static DisplayData getInstance () {
		if (instance == null) {
			instance = new DisplayData();
		}
		return instance;
	}

	private DisplayData () {
		taskListShop = TaskListShop.getInstance();

		tasksDataToDisplay = new Vector<TaskInfoDisplay>();
		formattingCommand = new Vector<FormatIdentify>();
		taskCountList = new Vector<Integer>();

		userFeedbackMessage = "";
		currentPage = 0;
		currentDisplayState = DISPLAY_STATE.TODAY;
	}

	private void updateTaskCountList() {
		taskCountList.clear();

		// TODO Hardcoded to get each task !!!!
		for (int i = 0; i < 6; i++) {
			int currentCount = 0;

			switch (i) {
			case 0:
				currentCount = taskListShop.getToday().size();
				break;
				
			case 1:
				currentCount = taskListShop.getFutureTasks().size();
				break;

			case 2:
				currentCount = taskListShop.getFloatingTasks().size();
				break;

			case 3:
				currentCount = taskListShop.getExpiredTasks().size();
				break;

			case 4:
				currentCount = taskListShop.getAllArchivedTasks().size();
				break;

			}
			taskCountList.add(currentCount);
		}
	}

	/**
	 * Updates the information with the Result object that is
	 * passed by parameter. 
	 * 
	 *  @param commandResult information of the command that is executed
	 */
	public void updateDisplayWithResult (Result commandResult) {
		// TODO Hardcoded way of forcing to show to default if there is no tasks to display

		// Update display state
		DISPLAY_STATE stateChange = commandResult.getDisplayState();
		if (stateChange != DISPLAY_STATE.INVALID) {
			currentDisplayState = stateChange; 
		}

		// Pull data from task view class
		extractTasksBasedOnDisplayState(currentDisplayState);
		setFeedbackMessage(commandResult.getFeedback());

		// Update header counters
		updateTaskCountList ();

		if (commandResult.getGoToNextPage()) {
			goToNextPage();
		} else if (commandResult.getGoToPrevPage()) {
			goToPreviousPage();
		}

		int maxPages = getMaxTaskDisplayPages(tasksDataToDisplay)-1;
		if (currentPage > maxPages) {
			currentPage = maxPages;
		}
		
		currentWeekDay = DateAndTimeFormat.getInstance().getCurrentWeekday().toUpperCase();
		currentDate = DateAndTimeFormat.getInstance().getDateToday();
		currentTime = DateAndTimeFormat.getInstance().getTimeNow();

		setChanged();
		notifyObservers();
	}
	
	public void updateDisplayWithResult () {
		extractTasksBasedOnDisplayState(currentDisplayState);
		updateTaskCountList ();
		
		int maxPages = getMaxTaskDisplayPages(tasksDataToDisplay)-1;
		if (currentPage > maxPages) {
			currentPage = maxPages;
		}
		
		setChanged();
		notifyObservers();
	}

	private void extractTasksBasedOnDisplayState(DISPLAY_STATE displayState) {
		setTaskDisplayToThese(TaskView.getInstance().setAndGetView(displayState), tasksDataToDisplay);
	}

	/**
	 * Returns a vector of TaskInfoDisplay which contains all the 
	 * tasks that is displayed.
	 * <p>
	 * This method always return DisplayData. The instance will be
	 * created when it is first called. Subsequent calls will return
	 * the first created instance.
	 *
	 */
	public Vector<TaskInfoDisplay> getAllTaskDisplayInfo () {
		return tasksDataToDisplay;
	}

	/**
	 * Returns a vector of TaskInfoDisplay which contains all the 
	 * tasks that is displayed. The size of vector is limited
	 * by the maximum page.
	 * <p>
	 * This method will get all the tasks on the current page and
	 * will be truncated to max task per page. 
	 *
	 */
	public Vector<TaskInfoDisplay> getTaskDisplay () {
		Vector<TaskInfoDisplay> selectedTaskToDisplay = new Vector<TaskInfoDisplay>();
		int startTaskIndex = currentPage*NUM_OF_TASK_PER_PAGE;
		int endTaskIndex = getLastIndexOfCurrentPage(currentPage);

		for (int i = startTaskIndex; i < endTaskIndex; i++) {
			selectedTaskToDisplay.add(tasksDataToDisplay.get(i));
		}

		return selectedTaskToDisplay;
	}

	private int getLastIndexOfCurrentPage(int startPage) {
		int maxCurrentPage = (currentPage+1)*NUM_OF_TASK_PER_PAGE;

		if (maxCurrentPage > tasksDataToDisplay.size()) {
			return tasksDataToDisplay.size();
		}

		return maxCurrentPage;
	}

	public void setTaskDisplayToThese (Vector<TaskInfo> taskList, Vector<TaskInfoDisplay> taskListToStoreIn) {
		taskListToStoreIn.clear();
		convertTasksIntoDisplayData(taskList, taskListToStoreIn);
	}

	private void convertTasksIntoDisplayData(Vector<TaskInfo> taskList, Vector<TaskInfoDisplay> taskListToAddinto) {
		for (int i = 0; i < taskList.size(); i++) {
			TaskInfo currentTaskInfo = taskList.get(i);
			TaskInfoDisplay infoToDisplay = convertTaskInfoIntoTaskInfoDisplay(currentTaskInfo, i+1);

			taskListToAddinto.add(infoToDisplay);
		}
	}

	private TaskInfoDisplay convertTaskInfoIntoTaskInfoDisplay(TaskInfo taskInfoToConvert, int taskId) {
		TaskInfoDisplay infoToDisplay = new TaskInfoDisplay();

		infoToDisplay.updateFromThisInfo(taskInfoToConvert);
		infoToDisplay.setTaskId(taskId);
		return infoToDisplay;
	}

	public String getFeedbackMessage () {
		return userFeedbackMessage;
	}

	public void setFeedbackMessage (String message) {
		userFeedbackMessage = message;
	}

	public int getMaxTaskDisplayPagesForCurrentView () {
		int maxPages = getMaxTaskDisplayPages(tasksDataToDisplay);

		return maxPages;
	}

	private int getMaxTaskDisplayPages (Vector<TaskInfoDisplay> taskUnderConcern) {
		if (taskUnderConcern.size() == 0) {
			return 1;
		} else {
			return ((taskUnderConcern.size()-1)/NUM_OF_TASK_PER_PAGE)+1;
		}
	}

	public int getCurrentPage () {
		return currentPage;
	}

	public void goToNextPage () {
		currentPage++;

		int maxPage = getMaxTaskDisplayPagesForCurrentView()-1;
		if (currentPage > maxPage) {
			currentPage = maxPage;
		}

		setChanged();
		notifyObservers();
	}

	public void goToPreviousPage () {
		if (currentPage > 0) {
			currentPage--;
		}

		setChanged();
		notifyObservers();
	}

	public DISPLAY_STATE getCurrentDisplayState() {
		return currentDisplayState;
	}

	public void setFormatDisplay (Vector<FormatIdentify> formatList) {
		formattingCommand = formatList;

		setChanged();
		notifyObservers();
	}

	public Vector<FormatIdentify> getFormatDisplay () {
		return formattingCommand;
	}

	public Vector<Integer> getTaskCountList () {
		return taskCountList;
	}
	
	public String getCurrentWeekDay () {
		return currentWeekDay;
	}
	
	public String getCurrentTime () {
		return currentTime;
	}
	
	public String getCurrentDate () {
		return currentDate;
	}
	
	public int getMaxTasksPerPage () {
		return NUM_OF_TASK_PER_PAGE;
	}
}

	// End of segment: src\kaboom\ui\DisplayData.java





	/**
	 * origin: src\kaboom\ui\DISPLAY_STATE.java
	 */


package kaboom.ui;

public enum DISPLAY_STATE {
	TODAY, FUTURE, TIMELESS, EXPIRED, ARCHIVE, SEARCH, 
	INVALID
}

	// End of segment: src\kaboom\ui\DISPLAY_STATE.java





	/**
	 * origin: src\kaboom\ui\GraphicInterface.java
	 */


package kaboom.ui;

import javafx.animation.Animation;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.fxml.FXMLLoader;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.util.Duration;
import kaboom.logic.TaskMasterKaboom;


public class GraphicInterface extends Application {
	
	private final int UPDATE_INTERVAL = 30;
	private final int WINDOW_WIDTH  = 700;
	private final int WINDOW_HEIGHT = 700;
	
	Parent root;
	MainWindow mainWindow;
	
	UpdateService myService;
	Timeline updateTimeline;
	
	private static TaskMasterKaboom controllerInstance;
	static int counter = 0;
	
	@Override
	public void start(Stage primaryStage) {
		FXMLLoader loader = null;
		try {
			loader = new FXMLLoader(getClass().getResource("TaskMasterKaboomUiUpgrade.fxml"));
			root = (Parent)(loader.load());
		} catch(Exception e) {
			e.printStackTrace();
		}
		
		mainWindow = loader.getController();
		mainWindow.setStage(primaryStage);
		
		Scene scene = new Scene(root);
		scene.setFill(null);
		primaryStage.setScene(scene);
		primaryStage.setResizable(false);
		primaryStage.initStyle(StageStyle.TRANSPARENT);
		primaryStage.setWidth(WINDOW_WIDTH);
		primaryStage.setHeight(WINDOW_HEIGHT);
		primaryStage.show();
		
		mainWindow.prepareTextfieldFocus();

		Image ico = new Image(this.getClass().getResourceAsStream("img/taskmasterkaboom.png"));
		primaryStage.getIcons().add(ico);
		
		updateTimeline = setupRunningUpdate();
		initialiseAndStartUpdateService();
	}

	private void initialiseAndStartUpdateService() {
		updateTimeline.setCycleCount(Animation.INDEFINITE);
		updateTimeline.playFrom("end");
	}

	private Timeline setupRunningUpdate() {
		myService = new UpdateService(mainWindow);

	    Timeline timeline = new Timeline(new KeyFrame(Duration.seconds(UPDATE_INTERVAL), new EventHandler<ActionEvent>() {
	    	@Override
			public void handle(ActionEvent event) {
	    		counter++;
	    		controllerInstance.updateTaskList();
	    		mainWindow.updateCounter(counter);
	    	}
	    }));
		return timeline;
	}
	
	public static void run(String[] args) {
		launch(args);
	}
	
	public static void main (String[] args) {
		controllerInstance = TaskMasterKaboom.getInstance();
		controllerInstance.initialiseKaboom(); 
		run(args);
	}
}

	// End of segment: src\kaboom\ui\GraphicInterface.java





	/**
	 * origin: src\kaboom\ui\MainWindow.java
	 */


package kaboom.ui;

import java.io.IOException;
import java.net.URL; 
import java.util.ArrayList;
import java.util.Collections;
import java.util.Observable;
import java.util.Observer;
import java.util.ResourceBundle; 
import java.util.Vector;

import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.image.ImageView;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.VBox;
import javafx.scene.shape.Rectangle;
import javafx.scene.shape.RectangleBuilder;
import javafx.stage.Stage;

import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

import kaboom.logic.FormatIdentify;
import kaboom.logic.TaskMasterKaboom;

public class MainWindow implements javafx.fxml.Initializable, Observer {	
	private final int MAX_TABS = 5;
	private final int MAX_COMMAND_KEEP = 20;
	
	// User interface elements
			private Stage 		windowStage;
	@FXML	private AnchorPane 	mainPane;
	
	// Data for the task table
			private ObservableList<TaskInfoDisplay> data;
			
	@FXML 	private Label		todayWeekDay;
	@FXML 	private Label		todayDate;
	@FXML 	private Label		todayTime;
			
	// Individual tasks
	Vector<TaskUiContainer> taskUiList;
	@FXML	private VBox		taskListContainer;
	
	// Top window toolbar buttons
	@FXML 	private ImageView 	exitButton;
	@FXML 	private ImageView 	minimiseButton;
	@FXML 	private Label 		counter;
	
	// Task header to show the current type of tasks displayed
	@FXML 	private Label header_today;
	@FXML 	private Label header_future;
	@FXML 	private Label header_timeless;
	@FXML 	private Label header_expired;
	@FXML 	private Label header_archive;
	
	@FXML 	private Label header_today_count;
	@FXML 	private Label header_future_count;
	@FXML 	private Label header_timeless_count;
	@FXML 	private Label header_expired_count;
	@FXML 	private Label header_archive_count;
	
	private final String HEADER_TODAY_NAME 		= "header_today";
	private final String HEADER_FUTURE_NAME 	= "header_future";
	private final String HEADER_TIMELESS_NAME 	= "header_timeless";
	private final String HEADER_EXPIRED_NAME 	= "header_expired";
	private final String HEADER_ARCHIVE_NAME 	= "header_archive";
	
	// List and tracks of previously activated headers
	private Vector<Label>	labelList;
	private int 			currentLabelIndex;
	private int 			previousLabelIndex;
	
	// Main command input and user feedback text
	@FXML private TextField 	commandTextInput;
	@FXML private Pane 			feedbackBox;
	@FXML private Label 		feedbackText;
	@FXML private HBox 			commandFormatFeedback;
	
	// Container to keep the pages tabs 
	@FXML private HBox 					pageTabContainer;
		  private ArrayList<Rectangle> 	pagesTab;
		  private final String NEXT_PAGE_KEYWORD = "next";
		  private final String PREV_PAGE_KEYWORD = "prev";
		  
	// Help boxes
	@FXML private Pane 	helpPane;
	@FXML private Pane 	helpAddPane;
	@FXML private Pane 	helpDeletePane;
	@FXML private Pane 	helpModifyPane;
	@FXML private Pane 	helpCompletePane;
	@FXML private Pane 	helpViewPane;
	@FXML private Pane 	helpSearchPane;
	
	private Pane 	currentActiveHelpPane;
	
	// Tracks previous commands
	private String currentCommand;
	private Vector<String> commandsEnteredList;
	private int currentCommandIndex;
	
	// Used in tracking window dragging
	private double initialX;
	private double initialY;
	
	// Class references
	private TaskMasterKaboom 	applicationController;
	private DisplayData 		uiData;
	
	// Logging unit and file handler for output
	private final static Logger loggerUnit = Logger.getLogger(MainWindow.class.getName());
	private static FileHandler fh;
	
	public MainWindow () {
		currentCommand = "";
		
		data = FXCollections.observableArrayList();
		pagesTab = new ArrayList<Rectangle>();
		
		uiData = DisplayData.getInstance();
		
		labelList = new Vector<Label>();
		
		commandsEnteredList = new Vector<String>();
		currentCommandIndex = 0;
		
		applicationController = TaskMasterKaboom.getInstance();
	}
	
	@Override
	public void initialize(URL location, ResourceBundle resources) throws NullPointerException {
		createAndStartLogging();
		
		taskUiList = new Vector<TaskUiContainer>();
		
		TaskUiContainer tempTaskUi;
		int maxTaskToDisplay = uiData.getMaxTasksPerPage();
		for (int i = 0; i < maxTaskToDisplay; i++) {
			tempTaskUi = new TaskUiContainer();
			taskListContainer.getChildren().add(tempTaskUi.getPaneContainer());
			
			taskUiList.add(tempTaskUi);
		}
		
		// Disable column reordering
		//disableTableColumnReordering();
		
		mainPane.getStyleClass().add("root");
		
		labelList.add(header_today);
		labelList.add(header_future);
		labelList.add(header_timeless);
		labelList.add(header_expired);
		labelList.add(header_archive);
		currentLabelIndex = 0;
		previousLabelIndex = 0;
		
		setHeaderLabelToSelected(labelList.get(currentLabelIndex));
		
		DisplayData.getInstance().addObserver(this);
		updateDisplay();
	}

	private void createAndStartLogging() {
		try {
			fh = new FileHandler("KaboomUI.log", false);
		} catch (SecurityException e) {
			// TODO find ways to handle exceptions
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		Logger logger = Logger.getLogger("");
		fh.setFormatter(new SimpleFormatter());
		logger.addHandler(fh);
		logger.setLevel(Level.CONFIG);
	}
	
	public void setStage (Stage currentStage) {
		windowStage = currentStage;
	}
	
	public void prepareTextfieldFocus () {
		commandTextInput.requestFocus();
	}
	
	@FXML
	private void onTextfieldAction (ActionEvent e) {
		String command = commandTextInput.getText();
		
		loggerUnit.log(Level.INFO, command);
		
		if (isExitCommand(command)) {
			Platform.exit();
			return;
		}
		
		// Check if need to switch header
		if (isPageToggle(command)) {
			activatePageToggle(command);
		} else if (isHelpCommand(command)) {
			activateHelpPane(command);
		} else {
			applicationController.processCommand(command);
		}
		
		// Store the command entered
		storeCommandEntered(command);
		
		commandTextInput.setText("");
	}

	private boolean isExitCommand(String command) {
		return command.equals("exit");
	}

	private void switchToNewHeader(int switchIndexResult) {
		// Is it the same label activated ?
		if (switchIndexResult == currentLabelIndex) {
			return;
		}
		
		if (switchIndexResult == -1) {
			previousLabelIndex = currentLabelIndex;
			setHeaderLabelToNormal(labelList.get(previousLabelIndex));
		} else {
			previousLabelIndex = currentLabelIndex;
			currentLabelIndex = switchIndexResult;
			switchMainHeaderHighlight(previousLabelIndex, currentLabelIndex);
		}
	}

	private void updateDisplay() {
		updateHeaderDateTime();
		updateTaskTable();
		updateFeedbackMessage();
		
		updateHeader();
		updateHeaderTaskCount();
		
		updatePagesTab();
		
		updateCommandFormat();
	}

	private void updateHeaderDateTime() {
		// TODO Auto-generated method stub
		todayWeekDay.setText(uiData.getCurrentWeekDay());
		todayDate.setText(uiData.getCurrentDate());
		todayTime.setText(uiData.getCurrentTime());
	}

	private void updateHeaderTaskCount() {
		Vector<Integer> taskCountList = uiData.getTaskCountList();
		for (int i = 0; i < taskCountList.size(); i++) {
			String countString = "" + taskCountList.get(i);
			
			switch (i) {
				case 0:
					header_today_count.setText(countString);
					break;
					
				case 1:
					header_future_count.setText(countString);
					break;
					
				case 2:
					header_timeless_count.setText(countString);
					break;
					
				case 3:
					header_expired_count.setText(countString);
					break;
					
				case 4:
					header_archive_count.setText(countString);
					break;
			}
		}
	}

	private void updateCommandFormat() {
		Label newLabel;
		
		// TODO
		if (commandFormatFeedback.getChildren() != null) {
			commandFormatFeedback.getChildren().clear();
		}
		
		// get the text
		String textToFormat = "";
		
		// Get list from uidata
		Vector<FormatIdentify> list = uiData.getFormatDisplay();
		
		// loop through the list
		for (int i = 0; i < list.size(); i++) {
			FormatIdentify currentInfo = list.get(i);
			
			if (currentInfo.getCommandStringFormat().equals("")) {
				continue;
			}
			
			textToFormat = currentInfo.getCommandStringFormat() + " ";	// Extra space is needed to separate each parsing info
			newLabel = new Label();
			newLabel.setText(textToFormat);
			
			switch (currentInfo.getType()) {
				case COMMAND:
					newLabel.getStyleClass().add("parseCommandTypeName");
					break;
					
				case TASKNAME:
				case VIEWTYPE:
				case MODIFIED_TASKNAME:
				case DATE:
				case CLEARTYPE:
					newLabel.getStyleClass().add("parseCommandName");
					break;
					
				case START_DATE:
				case START_TIME:
					newLabel.getStyleClass().add("parseCommandStartDate");
					break;
					
				case END_DATE:
				case END_TIME:
					newLabel.getStyleClass().add("parseCommandEndDate");
					break;
					
				case PRIORITY:
					newLabel.getStyleClass().add("parseCommandPriority");
					break;
					
				default:
					newLabel.getStyleClass().add("parseCommandInvalid");
					break;
			}
			
			commandFormatFeedback.getChildren().add(newLabel);
		}
	}

	private void updateHeader() {
		DISPLAY_STATE newDisplayState = uiData.getCurrentDisplayState();
		
		int newHeaderIndex = 0;
		switch (newDisplayState) {
			case TODAY:
				newHeaderIndex = 0;
				break;
				
			case FUTURE:
				newHeaderIndex = 1;
				break;
				
			case TIMELESS:
				newHeaderIndex = 2;
				break;
				
			case EXPIRED:
				newHeaderIndex = 3;
				break;
				
			case ARCHIVE:
				newHeaderIndex = 4;
				break;
				
			case SEARCH:
				newHeaderIndex = -1;
				break;
				
			default:
				return;
		}
		
		switchToNewHeader(newHeaderIndex);
	}

	private void activatePageToggle(String command) {
		switch (command) {
			case NEXT_PAGE_KEYWORD:
				uiData.goToNextPage();
				break;
				
			case PREV_PAGE_KEYWORD:
				uiData.goToPreviousPage();
				break;
				
			default:
				break;
		}
	}

	private boolean isPageToggle(String command) {
		switch (command) {
			case NEXT_PAGE_KEYWORD:
			case PREV_PAGE_KEYWORD:
				return true;
				
			default:
				return false;
		}
	}
	
	private void activateHelpPane (String command) {
		// Disable current help view
		if (currentActiveHelpPane != null) {
			currentActiveHelpPane.setVisible(false);
		}
		
		Pane paneToActivate = getPaneBasedOnCommand(command);
		if (currentActiveHelpPane != paneToActivate) {
			currentActiveHelpPane = paneToActivate;
			currentActiveHelpPane.setVisible(true);
		} else {
			currentActiveHelpPane = null;
		}
	}

	private Pane getPaneBasedOnCommand(String command) {
		switch (command) {
			case "help":
				return helpPane;
				
			case "help add":
				return helpAddPane;
				
			case "help delete":
				return helpDeletePane;
				
			case "help modify":
				return helpModifyPane;
				
			case "help complete":
				return helpCompletePane;
				
			case "help view":
				return helpViewPane;
				
			case "help search":
				return helpSearchPane;
				
			default:
				return null;
		}
	}

	private boolean isHelpCommand(String command) {
		switch (command) {
			case "help":
			case "help add":
			case "help delete":
			case "help modify":
			case "help complete":
			case "help view":
			case "help search":
				return true;
				
			default:
				return false;
		}
	}

	private void updateTaskTable() {
		data.clear();
		
		Vector<TaskInfoDisplay> taskList = uiData.getTaskDisplay();
		
//		for (int i = 0; i < taskList.size(); i++) {
//			data.add(taskList.get(i));
//		}
//		taskDisplayTable.setItems(data);
		
		// Update the data
		for (int i = 0; i < taskList.size(); i++) {
			TaskUiContainer currentTaskContainer = taskUiList.get(i);
			currentTaskContainer.updateWithTaskDisplay(taskList.get(i));
			currentTaskContainer.setVisibleFlag(true);
		}
		
		for (int i = taskList.size(); i < taskUiList.size(); i++) {
			TaskUiContainer currentTaskContainer = taskUiList.get(i);
			currentTaskContainer.setVisibleFlag(false);
		}
	}
	
	private void updateFeedbackMessage() {
		String feedback = uiData.getFeedbackMessage();
		feedbackText.setText(feedback);
	}
	
	private void storeCommandEntered(String command) {
		commandsEnteredList.add(command);
		
		while (commandsEnteredList.size() > MAX_COMMAND_KEEP) {
			commandsEnteredList.remove(0);
		}

		currentCommandIndex = commandsEnteredList.size();
	}
	
	private void recallPreviousCommand () {
		if (currentCommandIndex > 0) {
			currentCommandIndex--;
			commandTextInput.setText(commandsEnteredList.get(currentCommandIndex));
		}
	}
	
	private void recallStoredTypedCommand () {
		if (currentCommandIndex < commandsEnteredList.size()-1) {
			currentCommandIndex++;
			commandTextInput.setText(commandsEnteredList.get(currentCommandIndex));
		} else {
			currentCommandIndex =  commandsEnteredList.size();
			commandTextInput.setText(currentCommand);
		}
	}
	
	private void setTextfieldCursorToLast () {
		commandTextInput.positionCaret(commandTextInput.getText().length());
	}

	@FXML
	private void onTextfieldKeyReleased (KeyEvent keyEvent) {
		//System.out.println("Key pressed: " + keyEvent.getText());
		boolean processResult = false;
		
		switch(keyEvent.getCode()) {
			case UP:
				if (commandsEnteredList.size() < currentCommandIndex+1) {
					currentCommand = commandTextInput.getText();
				}
				
				loggerUnit.log(Level.FINE, "Recalling previous command.");
				recallPreviousCommand();
				setTextfieldCursorToLast();
				break;
				
			case DOWN:
				loggerUnit.log(Level.FINE, "Recalling next command.");
				recallStoredTypedCommand();
				setTextfieldCursorToLast();
				break;
				
			case ESCAPE:
				loggerUnit.log(Level.FINE, "ESC pressed for minimise.");
				windowStage.setIconified(true);
				break;
				
			case F1:
				activateHeaderBasedOnName(HEADER_TODAY_NAME);
				break;
				
			case F2:
				activateHeaderBasedOnName(HEADER_FUTURE_NAME);
				break;
				
			case F3:
				activateHeaderBasedOnName(HEADER_TIMELESS_NAME);
				break;
				
			case F4:
				activateHeaderBasedOnName(HEADER_EXPIRED_NAME);
				break;
				
			case F5:
				activateHeaderBasedOnName(HEADER_ARCHIVE_NAME);
				break;
				
			case PAGE_UP:
				uiData.goToNextPage();
				break;
				
			case PAGE_DOWN:
				uiData.goToPreviousPage();
				break;
				
			default:
				String command = commandTextInput.getText();
				if (isPageToggle(command) || isExitCommand(command)) {
					processResult = true;
				} else {
					processResult = applicationController.processSyntax(command);
				}
				
				updateCommandStatusIndicator(processResult);
				break;
		}
	}
	
	@FXML
	private void onExitButtonPressed (MouseEvent mouseEvent) {
		loggerUnit.log(Level.FINE, "Close button pressed.");
		Platform.exit();
	}
	
	@FXML
	private void onWindowMouseDrag (MouseEvent mouseEvent) {
		//System.out.printf("[%f, %f]\n", mouseEvent.getSceneX(), mouseEvent.getSceneY());
		
		windowStage.setX(mouseEvent.getScreenX() - initialX);
		windowStage.setY(mouseEvent.getScreenY() - initialY);
	}
	
	@FXML
	private void onWindowMousePressed (MouseEvent mouseEvent) {
		initialX = mouseEvent.getSceneX();
		initialY = mouseEvent.getSceneY();
	}
	
	@FXML
	private void onWindowKeyPressed (KeyEvent keyEvent) {
		//System.out.println("Key pressed: " + keyEvent.getText());
		
		if (!keyEvent.isControlDown()) {
			return;
		}
		
		previousLabelIndex = currentLabelIndex;
		switch(keyEvent.getCode()) {
			case LEFT:
				currentLabelIndex--;
				
				if (currentLabelIndex < 0) {
					currentLabelIndex = labelList.size()-1;
				}
				break;
				
			case RIGHT:
				currentLabelIndex++;
				currentLabelIndex %= labelList.size();
				break;
				
			default:
				break;
		}
		
		setHeaderLabelToNormal(labelList.get(previousLabelIndex));
		setHeaderLabelToSelected(labelList.get(currentLabelIndex));
	}
	
	@FXML
	private void onHeaderMouseClicked (MouseEvent mouseEvent) {
		Node nodePressed = (Node)mouseEvent.getSource();
		
		loggerUnit.log(Level.FINE, nodePressed.getId()+" header clicked.");
		// TODO need to activate the view command without creating string.
		activateHeaderBasedOnName(nodePressed.getId());
	}

	private void activateHeaderBasedOnName(String command) {
		switch (command) {
			case HEADER_TODAY_NAME:
				command = "view today";
				break;
				
			case HEADER_FUTURE_NAME:
				command = "view future";
				break;
				
			case HEADER_TIMELESS_NAME:
				command = "view timeless";
				break;
				
			case HEADER_EXPIRED_NAME:
				command = "view expired";
				break;
				
			case HEADER_ARCHIVE_NAME:
				command = "view archive";
				break;
				
			default:
				return;
		}
		
		applicationController.processCommand(command);
	}

	private void switchMainHeaderHighlight(int prevIndex, int currIndex) {
		setHeaderLabelToNormal(labelList.get(prevIndex));
		setHeaderLabelToSelected(labelList.get(currIndex));
	}
	
	private void setHeaderLabelToNormal (Label labelToChange) {
		labelToChange.getStyleClass().removeAll(Collections.singleton("header-label-selected"));
		labelToChange.getStyleClass().add("header-label-normal");
	}
	
	private void setHeaderLabelToSelected (Label labelToChange) {
		labelToChange.getStyleClass().removeAll(Collections.singleton("header-label-normal"));
		labelToChange.getStyleClass().add("header-label-selected");
	}
	
	@FXML
	private void onMinimiseMousePressed () {
		loggerUnit.log(Level.FINE, "Minimise button pressed.");
		windowStage.setIconified(true);
	}
	
	public void updateCounter(int number) {
		counter.setText("Test Counter: "+number);
	}
	
	@FXML
	private void onPagesArrowMouseClicked (MouseEvent mouseEvent) {
		Node nodePressed = (Node)mouseEvent.getSource();
		
		loggerUnit.log(Level.FINE, nodePressed.getId()+" button pressed.");
		switch (nodePressed.getId()) {
			case "nextArrow":
				uiData.goToNextPage();
				break;
				
			case "prevArrow":
				uiData.goToPreviousPage();
				break;
		}
		
		updateDisplay();
	}

	private void updatePagesTab() {
		int maxPages = uiData.getMaxTaskDisplayPagesForCurrentView();
		int maxTabs = maxPages;
		
		if (maxTabs > MAX_TABS) {
			maxTabs = MAX_TABS;
		}
		
		resizePageTabToMaxPages(maxTabs);
		updatePageTabStyles();
		refreshPageTabContainerWithNewPageTabs();
	}
	
	private Rectangle createPageTabRectangle() {
		RectangleBuilder pageTabBuilder = RectangleBuilder.create()
			    .x(100).y(100)
			    .width(25).height(5)
			    .styleClass("pagesOn");
		
		Rectangle rect1 = pageTabBuilder.build();
		return rect1;
	}

	private void updatePageTabStyles() {
		int currentTabPage = uiData.getCurrentPage()%MAX_TABS;
		for (int i = 0; i < pagesTab.size(); i++) {
			
			Rectangle currentTab = pagesTab.get(i);
			currentTab.getStyleClass().removeAll(Collections.singleton("pagesOn"));
			currentTab.getStyleClass().removeAll(Collections.singleton("pagesOff"));
			
			if (i == currentTabPage) {
				pagesTab.get(i).getStyleClass().add("pagesOn");
			} else {
				pagesTab.get(i).getStyleClass().add("pagesOff");
			}
		}
	}

	private void resizePageTabToMaxPages(int maxTab) {
		if (pagesTab.size() < maxTab) {
			int tabsToCreate = maxTab - pagesTab.size();
			for (int i = 0; i < tabsToCreate; i++) {
				pagesTab.add(createPageTabRectangle());
			}
		} else if (pagesTab.size() > maxTab ) {
			int tabsToDelete = pagesTab.size() - maxTab;
			for (int i = 0; i < tabsToDelete; i++) {
				pagesTab.remove(pagesTab.size()-1);
			}
		}
	}
	
	private void refreshPageTabContainerWithNewPageTabs() {
		pageTabContainer.getChildren().clear();
		pageTabContainer.getChildren().addAll(pagesTab);
	}

	@Override
	public void update(Observable arg0, Object arg1) {
		updateDisplay();
	}
	
	private void updateCommandStatusIndicator(boolean status) {
		String newStyleName;
		String styleToRemove;
		
		if (status) {
			newStyleName = "text-field-correct";
			styleToRemove = "text-field-wrong";
		} else {
			styleToRemove = "text-field-correct";
			newStyleName = "text-field-wrong";
		}
		
		changeStatusIndicatorStyle(styleToRemove, newStyleName);
	}
	
	private void changeStatusIndicatorStyle (String oldStyle, String newStyle) {
		commandTextInput.getStyleClass().removeAll(Collections.singleton(oldStyle));
		commandTextInput.getStyleClass().add(newStyle);
	}
}
	// End of segment: src\kaboom\ui\MainWindow.java





	/**
	 * origin: src\kaboom\ui\TaskInfoDisplay.java
	 */


package kaboom.ui;
import java.text.SimpleDateFormat;
import java.util.Calendar;

import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleIntegerProperty;
import javafx.beans.property.SimpleStringProperty;
import kaboom.logic.DateAndTimeFormat;
import kaboom.logic.TASK_TYPE;
import kaboom.logic.TaskInfo;

public class TaskInfoDisplay {
	private SimpleIntegerProperty taskId;
	private SimpleStringProperty taskName;
	
	private SimpleStringProperty startDate;
	private SimpleStringProperty endDate;
	
	private SimpleStringProperty importanceLevel;
	
	private SimpleBooleanProperty isExpired;
	private SimpleBooleanProperty isDone;
	private SimpleBooleanProperty isRecent;
	
	private DateAndTimeFormat dateTimeFormat;
	
	SimpleDateFormat fullTimeFormat = new SimpleDateFormat("h:mma");
	SimpleDateFormat fullDateFormat = new SimpleDateFormat("dd MMM yy");
	SimpleDateFormat dayMonthFormat = new SimpleDateFormat("dd MMM");
	SimpleDateFormat dayOnlyFormat = new SimpleDateFormat("EEE");
	
	public TaskInfoDisplay () {
		taskId = new SimpleIntegerProperty(0);
		taskName = new SimpleStringProperty("No taskname available");;
		startDate = new SimpleStringProperty("-");
		endDate = new SimpleStringProperty("-");
		importanceLevel = new SimpleStringProperty("");
		isExpired = new SimpleBooleanProperty(false);
		isDone = new SimpleBooleanProperty(false);
		isRecent = new SimpleBooleanProperty(false);
		
		dateTimeFormat = DateAndTimeFormat.getInstance();
	}
	
	public void updateFromThisInfo (TaskInfo infoToUpdateFrom) {
		setTaskName(infoToUpdateFrom.getTaskName());
		
		TASK_TYPE currentTaskType = infoToUpdateFrom.getTaskType();
		if (currentTaskType== TASK_TYPE.TIMED) {
			// Set time from ?? to ??
			setStartTime(infoToUpdateFrom.getStartDate());
			
			Calendar startTime = infoToUpdateFrom.getStartDate();
			Calendar endTime = infoToUpdateFrom.getEndDate();

			String startToDisplay = "From " + convertDateTimeFormatBasedOnTime(startTime);
			String endToDisplay = " to " + convertDateTimeFormatBasedOnTime(endTime);
			
			if (dateTimeFormat.isSameDay(startTime, endTime)) {
				// Remove the first day declaration
				int index = startToDisplay.indexOf(",");
				if (index > 0) {
					startToDisplay = startToDisplay.substring(0, index);
				}
			}
			
			startDate.set(startToDisplay+endToDisplay);
		} else if (currentTaskType == TASK_TYPE.DEADLINE) {
			// Due by ??
			
			Calendar dueTime = infoToUpdateFrom.getEndDate();
			String dueTimeToDisplay = "Due by " + convertDateTimeFormatBasedOnTime(dueTime);
			startDate.set(dueTimeToDisplay);
		}
		
		setImportanceLevel(infoToUpdateFrom.getImportanceLevel());
		
		setExpiryFlag(infoToUpdateFrom.getExpiryFlag());
		setDoneFlag(infoToUpdateFrom.getDone());
		setRecentFlag(infoToUpdateFrom.isRecent());
	}
	
	private String convertDateTimeFormatBasedOnTime(Calendar timeDate) {
		if (dateTimeFormat.isToday(timeDate)) {
			return fullTimeFormat.format(timeDate.getTime());
		} else if (dateTimeFormat.isThisWeek(timeDate)) {
			return fullTimeFormat.format(timeDate.getTime()) + ", " + dayOnlyFormat.format(timeDate.getTime());
		} else if (dateTimeFormat.isThisYear(timeDate)) {
			return fullTimeFormat.format(timeDate.getTime()) + ", " + dayMonthFormat.format(timeDate.getTime());
		} else {
			return fullTimeFormat.format(timeDate.getTime()) + ", " + fullDateFormat.format(timeDate.getTime());
		}
	}

	public void setTaskId (int id) {
		taskId.set(id);
	}
	
	public void setTaskName (String name) {
		taskName.set(name);
	}
	
	public void setStartTime (Calendar time) {
		if (time != null) {
			SimpleDateFormat timeFormat = new SimpleDateFormat("h:mma");
			SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yy");
			startDate.set(timeFormat.format(time.getTime()) + "\t" + dateFormat.format(time.getTime()));
		}
	}
	
	public void setEndTime (Calendar time) {
		if (time != null) {
			SimpleDateFormat timeFormat = new SimpleDateFormat("h:mma");
			SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yy");
			endDate.set(timeFormat.format(time.getTime()) + "\t" + dateFormat.format(time.getTime()));
		}
	}
	
	public void setImportanceLevel (int level) {
		if (level == 0) {
			importanceLevel.set("");
		} else {
			for (int i = 0; i < level; i++) {
				importanceLevel.set(importanceLevel.getValue() + "*");
			}
		}
	}
	
	public void setExpiryFlag (boolean flag) {
		isExpired.set(flag);
	}
	
	public void setDoneFlag (boolean flag) {
		isDone.set(flag);
	}
	
	public void setRecentFlag (boolean flag) {
		isRecent.set(flag);
	}
	
	public int getTaskId () {
		return taskId.get();
	}
	
	public String getTaskName () {
		return taskName.get();
	}
	
	public String getStartDate () {
		return startDate.get();
	}
	
	public String getEndDate () {
		return endDate.get();
	}
	
	public String getImportanceLevel () {
		return importanceLevel.get();
	}
	
	public boolean isExpired () {
		return isExpired.get();
	}
	
	public boolean isDone () {
		return isDone.get();
	}
	
	public boolean isRecent () {
		return isRecent.get();
	}
}


	// End of segment: src\kaboom\ui\TaskInfoDisplay.java





	/**
	 * origin: src\kaboom\ui\TaskUiContainer.java
	 */


package kaboom.ui;

import java.util.Collections;

import javafx.scene.control.Label;
import javafx.scene.layout.Pane;
import javafx.scene.shape.Rectangle;

public class TaskUiContainer {
 	private Pane 		task;
 	private Label 		taskid;
 	private Label 		taskname;
 	private Rectangle 	statusbar;
 	private Label 		datetime;
 	private Label 		priority;
 	private Rectangle 	backlitBox;
 	
 	
 	public TaskUiContainer () {
 		createTaskUi();
 	}
 	
 	public void createTaskUi () {
 		task = new Pane();
 		task.setPrefSize(512, 40);
 		
 		backlitBox = new Rectangle();
 		backlitBox.setWidth(512);
 		backlitBox.setHeight(40);
 		backlitBox.getStyleClass().add("taskbox-rectangle");
 		task.getChildren().add(backlitBox);
 		
 		taskid = new Label();
 		taskid.setPrefSize(50, 26.6);
 		taskid.setLayoutX(-59);
 		taskid.setLayoutY(5);
 		taskid.getStyleClass().add("taskid-label");
 		taskid.setMouseTransparent(true);
 		task.getChildren().add(taskid);
 		
 		taskname = new Label();
 		taskname.setPrefSize(479, 22);
 		taskname.setLayoutX(21);
 		taskname.setLayoutY(1);
 		taskname.getStyleClass().add("taskname-label");
 		taskname.setMouseTransparent(true);
 		task.getChildren().add(taskname);
 		
 		statusbar = new Rectangle();
 		statusbar.setWidth(5);
 		statusbar.setHeight(40);
 		statusbar.setMouseTransparent(true);
 		task.getChildren().add(statusbar);
 		
 		datetime = new Label();
 		datetime.setPrefSize(302, 19);
 		datetime.setLayoutX(21);
 		datetime.setLayoutY(19);
 		datetime.getStyleClass().add("taskdatetime-label");
 		datetime.setMouseTransparent(true);
 		task.getChildren().add(datetime);
 		
 		priority  = new Label();
 		priority.setPrefSize(80, 26.6);
 		priority.setLayoutX(418);
 		priority.setLayoutY(16);
 		priority.getStyleClass().add("taskpriority-label");
 		priority.setMouseTransparent(true);
 		task.getChildren().add(priority);
 	}
 	
 	public Pane getPaneContainer () {
 		return task;
 	}
 	
 	public void setupContainer (Pane taskLink, Label id, Label name, Rectangle status, Label date, Label priorityLink) {
 		task = taskLink;
 		taskid = id;
 		taskname = name;
 		statusbar = status;
 		datetime = date;
 		priority = priorityLink;
 	}
 	
 	public void setVisibleFlag (boolean flag) {
 		task.setVisible(flag);
 	}
 	
 	public void updateWithTaskDisplay (TaskInfoDisplay info) {
 		taskid.setText(""+info.getTaskId());
 		taskname.setText(info.getTaskName());
 		datetime.setText(info.getStartDate());
 		priority.setText(info.getImportanceLevel());
 		
 		statusbar.getStyleClass().removeAll(Collections.singleton("isNotExpired"));
 		statusbar.getStyleClass().removeAll(Collections.singleton("isExpired"));
 		statusbar.getStyleClass().removeAll(Collections.singleton("isComplete"));
 		statusbar.getStyleClass().removeAll(Collections.singleton("isEmpty"));
 		statusbar.getStyleClass().removeAll(Collections.singleton("isRecent"));
 		backlitBox.getStyleClass().removeAll(Collections.singleton("taskbox-rectangle"));
 		backlitBox.getStyleClass().removeAll(Collections.singleton("taskbox-recent-rectangle"));
 		
 		if (info.isExpired()) {
 			statusbar.getStyleClass().add("isExpired");
 			backlitBox.getStyleClass().add("taskbox-rectangle");
 		} else if (info.isDone()) {
 			statusbar.getStyleClass().add("isComplete");
 			backlitBox.getStyleClass().add("taskbox-rectangle");
 		} else if (info.isRecent()) {
 			backlitBox.getStyleClass().add("taskbox-recent-rectangle");
 			statusbar.getStyleClass().add("isNotExpired");
 		} else {
 			statusbar.getStyleClass().add("isNotExpired");
 			backlitBox.getStyleClass().add("taskbox-rectangle");
 		}
 	}
}

	// End of segment: src\kaboom\ui\TaskUiContainer.java





	/**
	 * origin: src\kaboom\ui\UpdateService.java
	 */


package kaboom.ui;

import javafx.application.Platform;
import javafx.concurrent.Service;
import javafx.concurrent.Task;
import kaboom.logic.TaskMasterKaboom;

class UpdateService extends Service<Void> {
	
	MainWindow mainWindow;
	int counter;
	TaskMasterKaboom controllerInstance;
	
	UpdateService (MainWindow window) {
		mainWindow = window;
		counter = 0;
		controllerInstance = TaskMasterKaboom.getInstance();
	}
	
    @Override
    protected Task<Void> createTask() {
    	return new Task<Void>() {
    		@Override
    		protected Void call() throws Exception {
    			//System.out.println("Begin task");
    			if (Platform.isFxApplicationThread()) {
    				System.out.println("Running on FX thread!");
    			} else {
    				System.out.println("Running on background thread!");
    			}
    			++counter;
    			controllerInstance.updateTaskList();
    			return null;
    		}
    	};
    }
}

	// End of segment: src\kaboom\ui\UpdateService.java





	/**
	 * origin: src\KaboomTest\Stage1.java
	 */


package KaboomTest;

import org.junit.runner.RunWith;
import org.junit.runners.Suite;
import org.junit.runners.Suite.SuiteClasses;

@RunWith(Suite.class)
@SuiteClasses({ LogicComponentTest.class, })
public class Stage1 {

}

	// End of segment: src\KaboomTest\Stage1.java





	/**
	 * origin: src\KaboomTest\Stage2.java
	 */


package KaboomTest;

import org.junit.runner.RunWith;
import org.junit.runners.Suite;
import org.junit.runners.Suite.SuiteClasses;


@RunWith(Suite.class)
@SuiteClasses({ 
		Stage1.class,
		StorageComponentTest.class
		})
public class Stage2 {


}

	// End of segment: src\KaboomTest\Stage2.java





	/**
	 * origin: src\KaboomTest\Stage3.java
	 */


package KaboomTest;

import org.junit.runner.RunWith;
import org.junit.runners.Suite;
import org.junit.runners.Suite.SuiteClasses;

@RunWith(Suite.class)
@SuiteClasses({ 
		Stage2.class,
		SystemTest.class
		})
public class Stage3 {

}

	// End of segment: src\KaboomTest\Stage3.java





	/**
	 * origin: src\KaboomTest\UIIntegrationTest.java
	 */


package KaboomTest;

import static org.junit.Assert.*;

import org.junit.Test;

public class UIIntegrationTest {

	@Test
	public void test() {
		fail("Dunno how to test UI");
	}

}

	// End of segment: src\KaboomTest\UIIntegrationTest.java





